#!/usr/bin/env python3

# MIT License
#
# Copyright (c) 2018-2023 Jonny Tyers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import annotations
from attrs import define
import colorama
import click
import os
import shlex
import shutil
import subprocess
import sys
from typing import Any
from typing import Generator
from typing import Optional

def expand(path):
    if path is None:
        return None

    if type(path) is list:
        return [os.path.expanduser(os.path.expandvars(x)) for x in path]

    elif type(path) is str:
        return " ".join(expand(path.split(" ")))

    else:
        return os.path.expanduser(os.path.expandvars(path))


xdg_runtime_dir = os.environ.get(
    "XDG_RUNTIME_DIR", expand(f"/run/user/{os.getuid()}")
)
xdg_config_home = os.environ.get("XDG_CONFIG_HOME", expand("$HOME/.config"))
xdg_cache_home = os.environ.get("XDG_CACHE_HOME", expand("$HOME/.cache"))
xdg_data_home = os.environ.get("XDG_DATA_HOME", expand("$HOME/.local/share"))

@define
class NoSuchProfileError(Exception):
    profile_name: str

@define
class ProfileAlreadyExistsError(Exception):
    profile_name: str

@define
class QutebrowserProfile:
    parent: QutebrowserProfiles
    profile_name: str
    session: str = 'default'

    @property
    def basedir(self):
        return os.path.join(f"{self.parent.xdg_runtime_dir}/qutebrowser/{self.profile_name}")

    def _dirs_and_links(self):
        return dict(
            dirs=[
                self.basedir,
                f"{self.parent.xdg_cache_home}/qutebrowser/{self.profile_name}",
                f"{self.parent.xdg_data_home}/qutebrowser/{self.profile_name}",
                f"{self.basedir}/runtime",
            ],
            links=[
                (f"{self.parent.xdg_cache_home}/qutebrowser/{self.profile_name}", f"{self.basedir}/cache"),
                (f"{self.parent.xdg_data_home}/qutebrowser/{self.profile_name}", f"{self.basedir}/data"),
                (f"{self.parent.xdg_config_home}/qutebrowser", f"{self.basedir}/config"),
            ],
        )

    def mkbasedir(self):
        # https://github.com/ayekat/localdir/blob/35fa033fb1274807c907a4a83431d3a8222283f6/lib/dotfiles/wrappers/qutebrowser
        # https://wiki.archlinux.org/index.php/Qutebrowser#dwb-like_session_handling
        #
        # Wrapper around qutebrowser that makes sessions (-r, --restore SESSION) behave
        # like they used to in dwb.
        #
        # We do so by filtering out the -r/--restore option passed to qutebrowser and
        # using the argument to set up the following directory structure and symbolic
        # links:
        #
        # $XDG_RUNTIME_DIR/qutebrowser/$session/cache → $XDG_CACHE_HOME/qutebrowser/$session
        # $XDG_RUNTIME_DIR/qutebrowser/$session/data → $XDG_STATE_HOME/qutebrowser/$session
        # $XDG_RUNTIME_DIR/qutebrowser/$session/data/userscripts → $XDG_DATA_HOME/qutebrowser/userscripts
        # $XDG_RUNTIME_DIR/qutebrowser/$session/config → $XDG_CONFIG_HOME/qutebrowser
        # $XDG_RUNTIME_DIR/qutebrowser/$session/runtime (no symlink, regular directory)
        #
        # We then specify $XDG_RUNTIME_DIR/qutebrowser/$session as a --basedir, and the
        # files will end up in their intended locations (notice how the config directory
        # is the same for all sessions, as there is no point in keeping it separate).
        #
        # DISCLAIMER: The author of this script manages all his configuration files
        # manually, so this wrapper script has not been tested for the use case where
        # qutebrowser itself writes to these files (and more importantly, if multiple
        # such "sessions" simultaneously write to the same configuration file).
        #
        # YOU HAVE BEEN WARNED.
        #
        # Written by ayekat in an burst of nostalgy, on a mildly cold wednesday night in
        # February 2017.
        #
        # Enhanced a little by jonny on a dreary cold Friday morning in December 2018.
        #

        dirs_and_links = self._dirs_and_links()

        for d in dirs_and_links['dirs']:
            os.makedirs(d, exist_ok=True)

        for src, dst in dirs_and_links['links']:
            if os.path.exists(dst):
                os.unlink(dst)
            os.symlink(src, dst, target_is_directory=False)

    def remove(self):
        # Delete the profile's directories and all associated links from the filesystem
        dirs_and_links = self._dirs_and_links()

        # do links first, as some (or all) of them will reside in basedir, which is one of the dirs
        for src, dst in dirs_and_links['links']:
            if os.path.exists(dst):
                if not os.path.issymlink(dst):
                    print(colorama.Fore.RED, f'warning: did not remove {dst} as it is not a symlink', colorama.Fore.RESET, file=sys.stderr)

                else:
                    print(colorama.Fore.YELLOW, f'removing {dst}', colorama.Fore.RESET, file=sys.stderr)
                    os.unlink(dst)

        for d in dirs_and_links['dirs']:
            if os.path.exists(d):
                if not os.path.isdir(d):
                    print(colorama.Fore.RED, f'warning: did not remove {d} as it is not a directory', colorama.Fore.RESET, file=sys.stderr)
                else:
                    print(colorama.Fore.YELLOW, f'removing {d}', colorama.Fore.RESET, file=sys.stderr)
                    shutil.rmtree(d, ignore_errors=True)


@define
class QutebrowserProfiles:
    profiles_root: str

    xdg_runtime_dir: str
    xdg_cache_home: str
    xdg_data_home: str
    xdg_config_home: str

    _profiles: Optional[list[QutebrowserProfile]] = None

    def _populate_profiles(self) -> list[QutebrowserProfile]:
        """Populates _profiles if needed, then returns them."""
        if self._profiles is None:
            self._profiles = []
            for item in os.listdir(self.profiles_root):
                if self._exists(item):
                    self._profiles.append(QutebrowserProfile(parent=self, profile_name=item))

        return self._profiles

    def profiles(self) -> list[QutebrowserProfile]:
        return list(self._populate_profiles())  # new list to prevent external changes

    def get_profile(self, profile_name: str) -> QutebrowserProfile:
        for profile in self._populate_profiles():
            if profile.profile_name == profile_name:
                return profile

        raise NoSuchProfileError(profile_name)

    def _exists(self, profile_name):
        """Checks if a profile with the given name exists under profiles_root. Looks at the filesystem
        and not at the _profiles cache."""
        item_path = os.path.join(self.profiles_root, profile_name)

        # our profilesRoot may contain dirs that are not qutebrowser profiles, so we look for
        # the 'state' file to determine whether something is a profile, and then pipe thru dirname
        # find "$profilesRoot" -mindepth 2 -maxdepth 2 -name state -type f -printf "%P\n" | xargs dirname
        return os.path.isdir(item_path) and os.path.exists(os.path.join(item_path, 'state'))

    def new(self, profile_name) -> QutebrowserProfile:
        """Creates a new QutebrowserProfile as part of this QutebrowserProfiles instance, including
        its profile dirs."""
        if self._exists(profile_name):
            raise ProfileAlreadyExistsError(profile_name)

        result = QutebrowserProfile(parent=self, profile_name=profile_name)
        self._populate_profiles().append(result)
        result.mkbasedir()

        return result


    def run_qb(self, qutebrowser: str, profile: QutebrowserProfile, args: list[Optional[str]] = [], show_stdio: bool = False):
        if not isinstance(profile, QutebrowserProfile):
            raise ValueError(f'profile must be a QutebrowserProfile, not {type(profile)}')

        # Set up session base directory, unless --basedir has been specified by the
        # user:
        profile.mkbasedir()

        # Translate options: remove occurrences of -r/--restore from the list of
        # command line arguments and save the session name for later
        for idx, arg in enumerate(args):
            if arg is None:
                continue
            if arg in ['--restore', '-r' ]:
                args[idx] = None
                args[idx+1] = None
            if arg in ['--override-restore', '-R' ]:
                args[idx] = None

        args_ = [ qutebrowser, '--basedir', profile.basedir ] + list(filter(lambda x: x is not None, args))

        stdin = None
        stderr = None
        stdout = None

        if not show_stdio:
            stdin = subprocess.DEVNULL
            stderr = subprocess.DEVNULL
            stdout = subprocess.DEVNULL

        p = subprocess.Popen(args_, stdin=stdin, stdout=stdout, stderr=stderr)
        print(f'started process {p.pid}')


@click.command(context_settings=dict(
    ignore_unknown_options=True,
))
@click.option(
    "--profiles-root",
    default=expand(f"{xdg_data_home}/qutebrowser"),  # "/run/user/$uid/qutebrowser"
    help="The directory to store profiles in",
)
@click.option(
    "--choose/--no-choose",
    default=False,
    help="Prompt the user to choose a profile, then launch it",
)
@click.option(
    "--load",
    default=None,
    help="Load the given profile (fails if profile does not exist, see --new)",
)
@click.option(
    "--remove",
    default=None,
    help="Delete the given profile (including cache, cookies, history, site data etc) from the filesystem",
)
@click.option(
    "--new/--no-new",
    default=False,
    help="Allow --load to create a new profile if it does not exist",
)
@click.option(
    "--dmenu",
    required=False,
    help="Override the location of dmenu/rofi when using --choose",
)
@click.option(
    "--only-existing/--no-only-existing",
    default=False,
    help="Do not allow the user to specify a new (non-existent) profile during --choose",
)
@click.option(
    "--list-profiles/--no-list-profiles", "--list/--no-list", '-l/ ',
    default=False,
    help="List existing profiles",
)
@click.option(
    "--show-stdio/--no-show-stdio",
    default=False,
    help="Show stdout/stderr from qutebrowser when it is launched",
)
@click.option(
    "--qutebrowser",
    default=shutil.which("qutebrowser"),
    help="Location of qutebrowser launcher",
)
# eat up remaining args to pass to qutebrowser
@click.argument('qb_args', nargs=-1, type=click.UNPROCESSED)
def main(
    profiles_root: str,
    choose: bool,
    load: Optional[str],
    remove: Optional[str],
    new: bool,
    dmenu: Optional[str],
    only_existing: bool,
    list_profiles: bool,
    qutebrowser: str,
    qb_args: tuple[str],
    show_stdio: bool,
):
    # Set default values as defined in XDG base directory spec
    # https://specifications.freedesktop.org/basedir-spec/latest/

    qp = QutebrowserProfiles(
        profiles_root=profiles_root,
        xdg_runtime_dir = xdg_runtime_dir,
        xdg_config_home = xdg_config_home,
        xdg_cache_home = xdg_cache_home,
        xdg_data_home = xdg_data_home,
    )

    # as we're using arguments to simulate commands, we have to manually enforce that
    # some commands aren't specified together
    @define
    class MutuallyExclusiveCommands:
        mutually_exclusive: list[tuple[str, Optional[Any]]]

        def check_if_any_mutually_exclusive(self, except_keys: list[str] = []) -> bool:
            # check if any args specified in 'mutually_exclusive' are set, except for any
            # specified under 'except_keys' (which should be arg strings, such as ['--load'])
            for k, v in self.mutually_exclusive:
                if k in except_keys:
                    continue
                if v:
                    return True

            return False

        def raise_if_any_mutually_exclusive(self, except_keys: list[str] = []):
            if self.check_if_any_mutually_exclusive(except_keys):
                raise click.BadParameter(f'cannot use {", ".join(map(lambda me: me[0], self.mutually_exclusive))} together')

    mutually_exclusive = MutuallyExclusiveCommands([
            ('--load', load),
            ('--choose', choose),
            ('--list', list_profiles),
            ('--remove', remove),
        ])

    if not mutually_exclusive.check_if_any_mutually_exclusive():
        choose = True

    if list_profiles:
        mutually_exclusive.raise_if_any_mutually_exclusive(except_keys=['--list'])

        profiles = qp.profiles()
        for profile in profiles:
            print(profile.profile_name)

    if choose:
        mutually_exclusive.raise_if_any_mutually_exclusive(except_keys=['--choose'])

        profiles = qp.profiles()

        if not dmenu:
            rofi = shutil.which("rofi")
            if rofi:
                dmenu = f"{rofi} -dmenu"

            dmenu = shutil.which("dmenu")

        if not dmenu:
            # use terminal selection
            for idx, profile in enumerate(profiles):
                print(f'{idx+1}. {profile.profile_name}')

            print('')
            print('Choose a number or name: ')
            ans = input()

            try:
                idx = int(ans)
                profile = profiles[idx-1]

            except ValueError: # ans wasn't a number
                profile = qp.get_profile(ans)

        else:

            dmenuArgs = shlex.split(dmenu) + ["-p", "qutebrowser"]

            if only_existing:
                dmenuArgs.append("-no-custom")

            p = subprocess.Popen(dmenuArgs,
                                     stdin=subprocess.PIPE,
                                     stderr=subprocess.PIPE,
                                     stdout=subprocess.PIPE)

            choice_lines = '\n'.join(map(lambda px: px.profile_name, profiles))
            choice, errors = p.communicate(choice_lines.encode('utf-8'))

            if p.returncode not in [0, 1] or (p.returncode == 1 and len(errors) != 0):
                raise ValueError(
                    "{} returned {} and error:\n{}"
                    .format(dmenuArgs, p.returncode, errors.decode('utf-8'))
                )

            profile_name = choice.decode('utf-8').rstrip()
            profile = qp.get_profile(profile_name)

        qp.run_qb(qutebrowser=qutebrowser, profile=profile, args=list(qb_args), show_stdio=show_stdio,)

    if load:
        mutually_exclusive.raise_if_any_mutually_exclusive(except_keys=['--load'])

        try:
            profile = qp.get_profile(load)

        except NoSuchProfileError:
            if new:
                profile = qp.new(load)
            else:
                raise

        qp.run_qb(qutebrowser=qutebrowser, profile=profile, args=list(qb_args), show_stdio=show_stdio)

    if remove:
        mutually_exclusive.raise_if_any_mutually_exclusive(except_keys=['--remove'])

        profile = qp.get_profile(remove)
        profile.remove()


if __name__ == '__main__':
    main()
